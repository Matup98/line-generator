# -*- coding: utf-8 -*-
"""new_2line_generator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q8Bj3i2Php5RkzIzWsBThA1d3EeyzUUN

### JSD1 filtrado cuadrado vs JSD1 filtrado rectangular
"""

import os
import numpy as np
from matplotlib import pyplot as plt
import networkx as nx
import sys
from scipy import interpolate
from enum import Enum

"""# Carga de Npy y Filtrado"""

JSD_original = np.load('imagenes/SAR/ImagenSAROriginal.npy')
JSD_f = np.load('imagenes/JSD/s1a-iw2-slc-hh-20210609INTJSD_f.npy')
JSD_c = np.load('imagenes/JSD/s1a-iw2-slc-hh-20210609INTJSD_c.npy')
JSD_2d = np.load('imagenes/JSD/s1a-iw2-slc-hh-20210609INTJSD_2d.npy')

"""### Grafico"""

JSD_original_max = JSD_original.max()
JSD_original_thr = JSD_original.std() * 2

plt.figure(figsize=(20, 10))
plt.imshow(JSD_original, cmap='gray')
plt.title('JSD_original')

JSD_max_c = JSD_c.max()
JSD_thr_c = JSD_c.std() * 2

plt.figure(figsize=(20, 10))
plt.imshow(JSD_c, vmin=JSD_thr_c, vmax=JSD_max_c / 2, cmap='gray')
plt.title('JSD_1d barrido por columnas')

JSD_max_f = JSD_f.max()
JSD_thr_f = JSD_f.std() * 2

plt.figure(figsize=(20, 10))
plt.imshow(JSD_f, vmin=JSD_thr_f, vmax=JSD_max_f / 2, cmap='gray')
plt.title('JSD_1d barrido por filas')

JSD_max_2d = JSD_2d.max()
JSD_thr_2d = JSD_2d.std() * 2

plt.figure(figsize=(20, 10))
plt.imshow(JSD_2d, vmin=JSD_thr_2d, vmax=JSD_max_2d / 2, cmap='gray')
plt.title('JSD_2d')

"""### Filtrado de la imagen imput antes del procesamiento"""

# Imagen Filtrada
img_filtered_c = np.where((JSD_c > JSD_thr_c * 2), JSD_c, 0)

# Imagen Filtrada y binarizada
img_filtered_bin_c = np.where((JSD_c > JSD_thr_c * 2), 1, 0)

# Imagen Filtrada
img_filtered_f = np.where((JSD_f > JSD_thr_f * 2), JSD_f, 0)

# Imagen Filtrada y binarizada
img_filtered_bin_f = np.where((JSD_f > JSD_thr_f * 2), 1, 0)

# Imagen Filtrada
img_filtered_2d = np.where((JSD_2d > JSD_thr_2d * 2), JSD_2d, 0)

# Imagen Filtrada y binarizada
img_filtered_bin_2d = np.where((JSD_2d > JSD_thr_2d * 2), 1, 0)

"""### Grafico luego del nuevo filtro (opcional)"""

plt.figure(figsize=(20, 10))
plt.title('JSD_1d barrido por columnas filtrada')
plt.imshow(img_filtered_bin_c, cmap='gray')
plt.show()

plt.figure(figsize=(20, 10))
plt.title('JSD_1d barrido por filas filtrada')
plt.imshow(img_filtered_bin_f, cmap='gray')
plt.show()

plt.figure(figsize=(20, 10))
plt.title('JSD_2d filtrada')
plt.imshow(img_filtered_bin_2d, cmap='gray')
plt.show()

"""### Cantidad de puntos y puntos blancos"""

print("Cantidad de 0s JSD_c antes del filtrado:", np.count_nonzero(JSD_c == 0))
print("Cantidad de 0s que tiene la imagen filtrada JSD_c:",
      np.count_nonzero(img_filtered_bin_c == 0))
print("Cantidad de puntos que tiene la imagen JSD_c:",
      img_filtered_bin_c.shape[0] * img_filtered_bin_c.shape[1])

print("\n")

print("Cantidad de 0s JSD_f antes del filtrado:", np.count_nonzero(JSD_f == 0))
print("Cantidad de 0s que tiene la imagen filtrada JSD_f:",
      np.count_nonzero(img_filtered_bin_f == 0))
print("Cantidad de puntos JSD_f:",
      img_filtered_bin_f.shape[0] * img_filtered_bin_f.shape[1])

print("\n")

print("Cantidad de 0s JSD_2d antes del filtrado:", np.count_nonzero(JSD_2d == 0))
print("Cantidad de 0s que tiene la imagen filtrada JSD_2d:",
      np.count_nonzero(img_filtered_bin_2d == 0))
print("Cantidad de puntos JSD_2d:",
      img_filtered_bin_2d.shape[0] * img_filtered_bin_2d.shape[1])

"""# Filtro por bloques"""


class NotBox(Exception):
    pass


def filter_block(img_filtered, n, m):
    """
    Realiza un filtro por bloques Rectangulares.

    Args:
      img_filtered (numpy.ndarray): Es la imagen de entrada que se desea filtrar. Debe ser un arreglo numpy.

      n (int): Es el tamaño del eje x para el filtro.

      m (int): Es el tamaño del eje y para el filtro.

    Returns:
      img_block_bin (numpy.ndarray): retorna la imagen filtrada como arreglo numpy.
    """

    # Verifica si n y m son nulos
    if (n is None or m is None):
        raise NotBox("Es necesario tener valores de n y m")

    # Se hace una copia de la imagen de entrada filtrada
    img_block_bin = np.copy(img_filtered)

    # Se itera a través de la imagen de entrada filtrada en bloques rectangulares
    for j in range(0, img_filtered.shape[1], n):
        for i in range(0, img_filtered.shape[0], m):

            # Se selecciona un bloque de la imagen de entrada filtrada del tamaño especificado por n y m
            block_array = img_filtered[i: i + m, j: j + n]

            # Se selecciona el elemento máximo del bloque
            max_elem = np.amax(block_array)

            # Si el elemento máximo del bloque es diferente de cero, se binariza el bloque de la imagen
            if max_elem != 0:
                block_bin = np.where(block_array == max_elem, 1, 0)
                img_block_bin[i: i + m, j: j + n] = block_bin

    # Se retorna la imagen filtrada como un arreglo numpy.
    return img_block_bin


"""# Creacion de Grafo unico para todo la imagen"""


def distance_from_origin_within_radius(x_origin, y_origin, x, y, radius):
    """
    Calcula la distancia entre un punto dado y otro punto de origen dado, solo si el punto dado está dentro de un radio dado.

    Args:
        x_origin (float): Coordenada x del punto de origen.
        y_origin (float): Coordenada y del punto de origen.
        x (float): Coordenada x del punto a medir la distancia.
        y (float): Coordenada y del punto a medir la distancia.
        radius (float): Radio dentro del cual se considera que el punto está dentro del rango.

    Returns:
        float: Distancia entre los puntos si el punto dado está dentro del radio, -1 en caso contrario.
    """
    # Calcula la distancia entre el punto dado y el punto de origen
    distance_squared = (x - x_origin) ** 2 + (y - y_origin) ** 2

    # Verifica si los puntos está dentro del circulo y devuelve la distancia si es así
    if distance_squared <= radius ** 2:
        return np.sqrt(distance_squared)

    # Devuelve -1 si los puntos estan fuera del circulo
    else:
        return -1


def img_to_graph(img_block_bin, max_range):
    """
    Crea un grafo uniendo nodos cercanos en un rango de píxeles dado.

    Args:
        img_block_bin (numpy.ndarray): Matriz binaria de la imagen.
        max_range (int): Rango máximo de conexión entre nodos.

    Returns:
        networkx.Graph: Grafo con nodos y aristas creados a partir de la matriz binaria.
    """
    # Se incia el grafo G, node_id, i_size y j_size
    G = nx.Graph()
    node_id = 0
    i_size, j_size = img_block_bin.shape

    # Se obtienen los índices de solo los puntos donde su valor sea 1
    indices = np.argwhere(img_block_bin == 1)

    # Se recorren los índices
    for i, j in indices:

        # Genero una key única para cada índice
        key = f"{i}-{j}"

        # Se agrega el puntos como nodo al grafo con su id
        G.add_node(key, coordinates=(i, j), id=node_id)
        node_id += 1

        # Se genera un rango de búsqueda de nodos vecinos
        initial_i, initial_j = max(i - max_range, 0), max(j - max_range, 0)
        final_i, final_j = min(i_size, i + max_range +
                               1), min(j_size, j + max_range + 1)

        # Se crea una submatriz con el rango para los vecinos
        submatrix = img_block_bin[initial_i:final_i, initial_j:final_j]

        # Se filtran solo los puntos con valor 1 ya que son los únicos posibles candidatos a vecinos
        h_indices, k_indices = np.where(submatrix == 1)

        # Se recorren los candidatos a vecinos
        for h, k in zip(h_indices + initial_i, k_indices + initial_j):

            # Se comprueba que el nodo vecino no sea el mismo
            if i != h or j != k:

                # Se calcula la distancia entre el nodo y su vecino
                distance = distance_from_origin_within_radius(
                    i, j, h, k, max_range)

                # Si se encuentra dentro del rango se agrega la arista
                if distance > 0:
                    G.add_edge(key, f"{h}-{k}", weight=distance)

    # Se retorna el grafo
    return G


"""# Definicion de algoritmo Kruskal"""


def swap(x, y):

   # Intercambia los valores de x e y usando el operador XOR (bitwise XOR)
    x ^= y

    # Ahora y contiene el valor original de x, ya que x ^= y sería x ^ (x ^ y) = y
    y ^= x

    # Finalmente, x contiene el valor original de y, ya que x ^= y sería (x ^ y) ^ y = x
    x ^= y

    return x, y


def uf_find(id, rep):
    # Si el representante de id es negativo, significa que id es su propio representante
    if rep[id] < 0:
        return id

    # Si no, se busca recursivamente el representante del padre de id
    rep[id] = uf_find(rep[id], rep)

    # Se actualiza el representante de id para apuntar directamente al representante de su conjunto
    return rep[id]


def uf_join(id1, id2, new_graph, rep, name_list):
    # Se encuentra el representante de cada nodo.
    x = uf_find(id1, rep)
    y = uf_find(id2, rep)

    # Si el representante de x es mayor que el de y, se intercambian.
    if rep[x] > rep[y]:
        swap(x, y)

    # Se actualiza la representación y el tamaño de la componente.
    rep[x] += rep[y]
    rep[y] = x

    # Se obtienen y agregan los nombres de los nodos al nuevo grafo.
    tuples = (name_list[id1], name_list[id2])
    new_graph.append(tuples)


def kruskal(grafo):
    """
    Implementación del algoritmo de Kruskal para encontrar el árbol de expansión mínima de un grafo no dirigido.

    Args:
        grafo (nx.Graph): Grafo no dirigido representado como un objeto de la clase nx.Graph de la biblioteca NetworkX.

    Returns:
        Tuple(list, np.array): Una tupla que contiene el árbol de expansión mínima representado como una lista de aristas y la estructura de datos de representación de conjuntos disjuntos utilizada por el algoritmo.
    """
    # Se obtienen y ordenar aristas por peso
    distance = sorted(grafo.edges(data=True),
                      key=lambda e: e[2].get('weight', 1))

    # Se obtienen y ordenar nodos por id
    nodes = sorted(grafo.nodes(data=True), key=lambda n: n[1]['id'])

    # Se obtiene un diccionario del atributo id para cada nodo del grafo
    id_list = nx.get_node_attributes(grafo, 'id')

    # Se inicializa una lista vacía para almacenar el nombre de cada nodo
    name_list = [None] * len(nodes)

    # Se asignan los nombres de cada nodo en una lista de nombres
    for node in nodes:
        name_list[node[1]['id']] = node[0]

    # Se inicializa la estructura de datos de conjuntos disjuntos / representantes
    rep = np.full(len(nodes), -1, dtype=int)

    # Inicializar el árbol de expansión mínima
    new_graph = []
    for elem in distance:
        # Obtener el id del primer nodo en la arista
        id1 = id_list[elem[0]]

        # Obtener el id del segundo nodo en la arista
        id2 = id_list[elem[1]]

        # Verificar si los nodos ya están conectados en el árbol
        if uf_find(id1, rep) == uf_find(id2, rep):
            # Si ya están conectados, no se hace nada
            pass

        else:
            # Si no están conectados, se une los nodos en el árbol
            uf_join(id1, id2, new_graph, rep, name_list)

    # Se retorna el árbol de expansión mínima y la estructura de datos de conjuntos disjuntos
    return new_graph, rep


"""# Creacion del arbol"""


def generate_tree(kruskal_list, G):
    """
    Genera un árbol a partir de una lista de aristas obtenidas mediante el algoritmo de Kruskal.

    Args:
        kruskal_list (list): Lista de aristas obtenidas mediante el algoritmo de Kruskal.
        G (nx.Graph): Grafo original representado como un objeto de la clase nx.Graph de la biblioteca NetworkX.

    Returns:
        nx.Graph: Árbol generado a partir de la lista de aristas, representado como un objeto de la clase nx.Graph de NetworkX.
    """
    # Se obtiene un diccionario con el atributo 'id' de cada nodo del grafo
    id_dict = nx.get_node_attributes(G, 'id')

    # Se obtiene un diccionario con el atributo 'coordinates' de cada nodo del grafo
    coordinates_dict = nx.get_node_attributes(G, 'coordinates')

    # Se obtiene un diccionario con el 'weight' de cada arista del grafo
    weight_dict = nx.get_edge_attributes(G, "weight")

    # Se crea un diccionario con los nodos del grafo original que contiene el atributo 'id' y el atributo 'coordinates'
    nodes_dict = {
        k: {'coordinates': coordinates_dict[k], 'id': id_dict[k]} for k in id_dict}

    # Se crea un grafo vacío para almacenar el árbol
    tree = nx.Graph()

    # Se agregan los nodos del grafo original al grafo del árbol
    tree.add_nodes_from(nodes_dict.items())

    # Se itera sobre las aristas obtenidas por el algoritmo de Kruskal
    for elem in kruskal_list:

        # Se obtienen los nodos que forman la arista
        key1, key2 = elem[:2]

        # Se agrega la arista al árbol con el atributo 'weight' correspondiente
        tree.add_edge(key1, key2, weight=weight_dict[elem])

    # Se devuelve el grafo del árbol generado
    return tree


def graph_to_tree(graph):
    """
    Convierte un grafo en un árbol de expansión mínima utilizando el algoritmo de Kruskal.

    Args:
        graph (nx.Graph): Grafo original representado como un objeto de la clase nx.Graph de la biblioteca NetworkX.

    Returns:
        Tuple(nx.Graph, np.array): Una tupla que contiene el árbol de expansión mínima representado como un objeto de la clase nx.Graph de NetworkX, y la estructura de datos de representación de conjuntos disjuntos utilizada por el algoritmo de Kruskal.
    """
    # Se obtiene la lista de aristas del árbol de expansión mínima y la estructura de datos utilizada por Kruskal
    kruskal_list, rep = kruskal(graph)

    # Se genera un árbol a partir de la lista de aristas obtenida
    tree = generate_tree(kruskal_list, graph)

    # Retorna el árbol y la estructura de datos como una tupla
    return tree, rep


"""#Definicion de finciones para DFS"""


def complete_list(G):
    """
    Genera una lista completa de todas las aristas en un grafo G, incluyendo sus reversos.

    Args:
        G (nx.Graph): Grafo original representado como un objeto de la clase nx.Graph de la biblioteca NetworkX.

    Returns:
        list: Lista completa de todas las aristas del grafo, incluyendo sus reversos, ordenadas alfabéticamente.
    """
    # Se crea una lista con todas las aristas del grafo
    edges = list(G.edges)

    # Se crea una lista de las aristas invertidas del grafo
    reversed_edges = [e[::-1] for e in edges]

    # Se crea una lista que contenta las aristas del grafo y su reverso
    all_edges = edges + reversed_edges

    # Se retorna una lista completa de aristas del grafo ordenadas alfabéticamente
    return sorted(all_edges, key=lambda e: str(e))


def list_to_dict(datalist):
    """
    Convierte una lista de tuplas en un diccionario, agrupando los valores por clave.

    Args:
        datalist (list): Lista de tuplas con claves y valores.

    Returns:
        dict: Diccionario con las claves como claves y los valores agrupados en listas.
    """

    result = {}
    # Se recorren los elementos de la lista
    for (key, value) in datalist:

        # Agrupa los valores por clave en un diccionario
        result.setdefault(key, []).append(value)

    # Devuelve el diccionario resultante
    return result


def dfs_with_end(graph_dic, start, end):
    """
    Realiza una búsqueda en profundidad (DFS) en un grafo representado como un diccionario de adyacencia, buscando un nodo de inicio hasta encontrar un nodo objetivo.

    Args:
        graph_dic (dict): Diccionario de adyacencia que representa el grafo.
        start (str: int-int): Nodo de inicio de la búsqueda.
        end (str: int-int): Nodo objetivo a buscar.

    Returns:
        np.array: Un array con la ruta encontrada desde el nodo de inicio hasta el nodo objetivo, representada como una secuencia de nodos.
    """
    global visited, road, stack

    # Conjunto de nodos visitados
    visited = set()

    # Lista de nodos que forman la ruta encontrada
    road = []

    # Pila que contiene los nodos que se están visitando
    stack = []

    def dfs(x):

        # Si el nodo ya fue visitado, no se hace nada
        if x in visited:
            return

        # Si la ruta ya fue encontrada, no se hace nada
        if len(road) != 0:
            return

        # Se agrega el nodo actual al conjunto de nodos visitados
        visited.add(x)

        # Se agrega el nodo actual a la pila de nodos visitados
        stack.append(x)

        # Si el nodo actual es el nodo objetivo, se agrega la ruta a la lista de rutas encontradas
        if x == end:
            road.extend(np.copy(stack))

        # Se itera sobre los nodos adyacentes al nodo actual
        for elem in graph_dic[x]:
            dfs(elem)

        # Se elimina el nodo actual de la pila de nodos visitados
        stack.pop()

    # Llamada inicial a la función dfs
    dfs(start)

    # Se copia la lista de nodos que forman la ruta encontrada
    result = np.copy(road)

    # Se eliminan las variables globales utilizadas
    del visited, stack, road

    # Retorna la lista de nodos que forman la ruta encontrada
    return result


"""## checkeo para saber si el camino entre 2 puntos existe y corrida del DFS"""


def is_existing_road(graph, rep, start, end):
    """
    Verifica si existe un camino entre dos nodos en un grafo representado como un árbol de expansión mínima utilizando la estructura de conjuntos disjuntos obtenida del algoritmo de Kruskal.

    Args:
        graph (nx.Graph): Grafo representado como un objeto de la clase nx.Graph de la biblioteca NetworkX.
        rep (np.array): Estructura de conjuntos disjuntos obtenida del algoritmo de Kruskal.
        start (str: int-int): Nodo de inicio del camino.
        end (str: int-int): Nodo de fin del camino.

    Returns:
        bool: True si existe un camino entre los dos nodos, False en caso contrario.
    """

    # Se obtiene un diccionario de nodos y sus id
    id_dict_tree = nx.get_node_attributes(graph, 'id')

    # Busca los id de los nodos de inicio y fin
    elem1 = id_dict_tree[start]
    elem2 = id_dict_tree[end]

    # Se usa la estructura de conjuntos disjuntos para verificar si los nodos están conectados
    if uf_find(elem1, rep) == uf_find(elem2, rep):
        return True
    else:
        return False


def found_road(graph, rep, start_node, end_node):
    """
    Busca un camino entre dos nodos en un grafo representado como un objeto de la clase nx.Graph de NetworkX, utilizando el algoritmo de búsqueda en profundidad (DFS).

    Args:
        graph (nx.Graph): Grafo original representado como un objeto de la clase nx.Graph de la biblioteca NetworkX.
        rep (np.array): Estructura de datos de representación de conjuntos disjuntos utilizada por el algoritmo de Kruskal.
        start_node (str: int-int): Nodo de inicio del camino.
        end_node (str: int-int): Nodo de fin del camino.

    Returns:
        List or None: Una lista que contiene el camino encontrado entre los dos nodos, si existe. None si no se encuentra un camino entre los nodos o si los nodos no son válidos.
    """
    # Se obtienen los nodos del grafo
    nodes = graph.nodes()

    # Se verifica que el nodo inicial sea válido
    if not (start_node in nodes):
        print(f'El nodo inicial: ({start_node}) no es un nodo válido')
        return

    # Se verifica que el nodo final sea válido
    if not (end_node in nodes):
        print(f'El nodo final: ({start_node}) no es un nodo válido')
        return

    # Si existe una ruta entre el nodos inicial y final
    if is_existing_road(graph, rep, start_node, end_node):

        # Se crea una lista con todos los nodos del grafo
        complete = complete_list(graph)

        # Se convierte la lista de nodos en un diccionario
        graphDict = list_to_dict(complete)

        # Se realiza la búsqueda en profundidad del camino entre el nodos inicial y final
        return dfs_with_end(graphDict, start_node, end_node)

    # Si no existe un camino entre el nodos inicial y final
    else:
        print('No hay camino entre nodos')
        return


"""# Codigo de prueba para encontrar caminos posibles entre la seccion inicial y final, NO ES ALGO NECESARIO"""


def check_all_roads(graph, rep, initials, endings):
    """
    Verifica todas las rutas en un grafo dado, utilizando la representación, nodos iniciales y finales dados.

    Args:
        graph (nx.Graph): Grafo de entrada.
        rep (dict): Representación de nodos en el grafo.
        initials (array): Lista de nodos iniciales.
        endings (array): Lista de nodos finales.

    Returns:
        list (array): Lista de opciones de ruta válidas, representadas como pares de claves de nodos.

    """
    # Creamos una lista vacía que almacenará todas las opciones de rutas válidas.
    options = []

    # Obtenemos el atributo "id" de cada nodo del grafo y lo almacenamos en un diccionario.
    id_dict_tree = nx.get_node_attributes(graph, 'id')

    # Recorremos cada elemento inicial y final de la lista de nodos iniciales y finales.
    for elem_inicio in initials:
        for elem_final in endings:
            # Creamos una clave para cada elemento inicial y final a partir de su índice 0 y 1.
            key_1 = f"{elem_inicio[0]}-{elem_inicio[1]}"
            key_2 = f"{elem_final[0]}-{elem_final[1]}"

            try:
                # accedecemos a los elementos 1 y 2 del diccionario a través de sus claves.
                elem1 = id_dict_tree[key_1]
                elem2 = id_dict_tree[key_2]

                # Utilizamos la función "uf_find" para encontrar el conjunto al que pertenecen los elementos.
                a = uf_find(elem1, rep)
                b = uf_find(elem2, rep)

                # Si los elementos pertenecen al mismo conjunto, entonces añadimos las claves a la lista de opciones válidas.
                if a == b:
                    options.append((key_1, key_2))

            # Si los elementos no pertenecen al mismo conjunto, se omite el error y se continúa con la siguiente iteración.
            except:
                pass

    # Retornamos la lista de opciones de rutas válidas.
    return options


"""Recoracta las cordenadas de todos los puntos en las secciones dadas"""


def collect_points(img, x_start, x_end, y_start, y_end):
    """
    Extrae las coordenadas de los puntos con valor 1 en un área especificada de una imagen binaria.

    Argumentos:
    - img (numpy.ndarray) representa la imagen binaria.
    - x_start (int): Coordenada de inicio en el eje x.
    - x_end (int): Coordenada de fin en el eje x.
    - y_start (int): Coordenada de inicio en el eje y.
    - y_end (int): Coordenada de fin en el eje y.

    Retorna:
    -numpy.ndarray: contiene las coordenadas de los puntos con valor 1 en el área especificada,
                 ajustadas a las coordenadas reales en la imagen original.
    """
    # Se hace una copia de la sección de la imagen correspondiente al área especificada
    area = np.copy(img[x_start:x_end, y_start:y_end])

    # Se obtienen los índices de los puntos con valor 1
    indices = np.argwhere(area == 1)

    # Ajusta los índices a las coordenadas reales en la imagen original
    indices[:, 0] += x_start
    indices[:, 1] += y_start

    # Retorna los índices ajustados como un numpy array
    return indices


"""devuelvo lista de pares (inicio, final)"""


def find_valid_extreme_points(imgBlockBin, tree, rep, start_area, end_area):
    """
    Encuentra los puntos extremos que tengan un camino que los conecte en una imagen binaria.

    Args:
        imgBlockBin (numpy.ndarray): Imagen binaria.
        tree (nx.Graph): Objeto de arbol.
        rep (array): lista de representación.
        start_area (dict): Área de inicio con coordenadas de inicio y fin.
        end_area (dict): Área de fin con coordenadas de inicio y fin.

    Returns:
        list: Lista de opciones de puntos extremos con camino.
    """
    # Lista de posibles inicios
    initials = collect_points(
        imgBlockBin, start_area['y_start'], start_area['y_end'], start_area['x_start'], start_area['x_end'])

    # Lista de posibles finales
    endings = collect_points(
        imgBlockBin, end_area['y_start'], end_area['y_end'], end_area['x_start'], end_area['x_end'])

    # Prueba todos los posibles inicios con todos los posibles finales para ver cuales de ellos estan conectados
    options = check_all_roads(tree, rep, initials, endings)

    return options


"""# Graficador del resultado con puntos, linea original e interpolacion"""


def generate_line(background_img, dotted_road, title='', plot_interpolate_line=True, plot_line=False, plot_dots=False, k=5, s=10000):
    """
   Genera el borde interpolado sobre la imagen original como fondo. También puede graficar solo los puntos sin interpolar o el borde sin interpolación.

    Args:
        background_img (numpy.ndarray): Imagen de fondo.
        dotted_road (list): Lista de coordenadas de puntos.
        title (str, optional): Título de la figura.
        plot_interpolate_line (bool, optional): Indica si se debe trazar la línea interpolada.
        plot_line (bool, optional): Indica si se debe trazar la línea original de puntos.
        plot_dots (bool, optional): Indica si se deben graficar los puntos.
        k (int, optional): Orden del spline para la interpolación.
        s (int, optional): Valor de suavidad para la interpolación.

    Returns:
        None
    """
    # Obtiene las coordenadas x e y de los puntos
    x_elems = [int(coord.split('-')[1]) for coord in dotted_road]
    y_elems = [int(coord.split('-')[0]) for coord in dotted_road]

    # Interpola la curva con splprep
    tck, u = interpolate.splprep([x_elems, y_elems], k=k, s=s, task=0)
    out = interpolate.splev(u, tck)

    # Crea la figura
    plt.figure(figsize=(20, 20))
    plt.imshow(background_img, cmap='gray')
    plt.title(title)

    # Grafica los puntos, línea original y línea interpolada si se indica
    if plot_dots:
        plt.plot(x_elems, y_elems, '.', markersize=5, markeredgecolor="red")

    if plot_line:
        plt.plot(x_elems, y_elems, 'g', linewidth='3')

    if plot_interpolate_line:
        plt.plot(out[0], out[1], 'b', linewidth='3')

    # Mustra la figura
    plt.show()


"""# Ejecucion"""


class NotValidExtremePoints(Exception):
    pass


def unificate_imgs(JSD_c, JSD_f):
    """
    Unifica dos imágenes JSD_c y JSD_f en una nueva imagen JSD de 1 dimension.

    Args:
        JSD_c (numpy.ndarray): Imagen JSD_c.
        JSD_f (numpy.ndarray): Imagen JSD_f.

    Returns:
        array: Nueva imagen unificada.
    """
    # Se verifica que las dosm imagenes tengan las mismas dimenciones
    if (JSD_c.shape != JSD_f.shape):
        raise ValueError('Las imágenes deben ser del mismo tamaño.')

    # Corrige la imagen JSD_c desplazandola por 25 pixeles debido a un error en su creación.
    fixed_JSD_c = np.roll(JSD_c, 25, axis=0)

    # Crea la nueva imagen a partir del máximo de cada píxel en ambas imágenes originales.
    new_img = new_img = np.maximum(fixed_JSD_c, JSD_f)

    return new_img


class JSD(Enum):
    D1 = '1d'
    D2 = '2d'


class NotJSDEnum(Exception):
    pass


class NotImgsD1(Exception):
    pass


class NotImgsD2(Exception):
    pass


def run_jsd(jsd_type, n, m, range, start_area, end_area, k, s, background_img, title='', plot_interpolate_line=None, plot_line=None, plot_dots=None, img_filtered_c=None, img_filtered_f=None, img_filtered_2d=None,):
    """
    Args:
        img_filtered_c (numpy.ndarray): Imagen filtrada de la imagen JSD_c.
        img_filtered_f (numpy.ndarray): Imagen filtrada del la imagen JSD_f en formato numpy array.
        filter_type (Enum): Es el tipo de filtro a aplicar, representado como un objeto de tipo Filter. Se espera que sea de tipo enumerado Filter y puede tener los valores 'circle' o 'box'.
        n (int): Es el tamaño del eje x para el filtro de tipo 'box'. No es requerido si se está utilizando un filtro de tipo 'circle'.
        m (int): Es el tamaño del eje y para el filtro de tipo 'box'. No es requerido si se está utilizando un filtro de tipo 'circle'.
        r (int): Es el radio del kernel para el filtro de tipo 'circle'. No es requerido si se está utilizando un filtro de tipo 'box'.
        range (int): Rango máximo de conexión entre nodos.
        start_area (object): Área en la que se buscarán los puntos de inicio del camino en la imagen.
        end_area (object): Área en la que se buscarán los puntos finales del camino en la imagen.
        k (int, optional): Orden del spline para la interpolación.
        s (int, optional): Valor de suavidad para la interpolación.
        plot_interpolate_line (bool, optional): Indica si se debe trazar la línea interpolada.
        plot_line (bool, optional): Indica si se debe trazar la línea original de puntos.
        plot_dots (bool, optional): Indica si se deben graficar los puntos.
        background_img (numpy.ndarray): Imagen de fondo.
        title (string): Título para la figura generada.
    Returns:
        None
    """
    # Es necesario para que found_road funcione, ya que excede el límite máximo de recursión permitida en Python
    sys.setrecursionlimit(10000)

    # Verifica si jsd_type es un tipo Filter
    if not isinstance(jsd_type, JSD):
        raise NotJSDEnum("El tipo de filtro no es de tipo JSD")

    # Verifica si jsd_type es de tipo Filter.D1 y si img_filtered_c, img_filtered_f son nulos
    if jsd_type == JSD.D1 and (img_filtered_c is None or img_filtered_f is None):
        raise NotImgsD1(
            "Es necesario tener imagen img_filtered_c y img_filtered_f")

    # Verifica si jsd_type es de tipo Filter.D2 y si img_filtered_2d es nula
    if jsd_type == JSD.D2 and img_filtered_2d is None:
        raise NotImgsD2("Es necesario tener imagen img_filtered_2d")

    if jsd_type == JSD.D1:

        # Filtrado por bloques de las imágenes de entrada
        img_block_bin_c = filter_block(img_filtered_c, n, m)
        img_block_bin_f = filter_block(img_filtered_f, m, n)

        # Unificación de las imágenes filtradas por bloques
        img_block_bin = unificate_imgs(img_block_bin_c, img_block_bin_f)

    else:
        # Filtrado por bloques de las imágenes de entrada
        img_block_bin = filter_block(img_filtered_2d, n, m)

    # Creación del grafo a partir de la imagen filtrada por bloques
    G = img_to_graph(img_block_bin, range)

    # Creación del árbol generador a partir del grafo
    tree, rep = graph_to_tree(G)

    # Selección de los pares de puntos iniciales y finales
    extreme_points = find_valid_extreme_points(
        img_block_bin, tree, rep, start_area, end_area)

    # Si hay caminos posibles entre los puntos extremos, elegimos uno y generamos la línea que los conecta
    if extreme_points:
        # Elegimos el punto inicial y final
        start_node = extreme_points[0][0]
        end_node = extreme_points[0][1]
        print('Start:', start_node, 'End:', end_node)

        # Corremos DFS en el árbol para encontrar el camino que conecta los puntos extremos
        dotted_road = found_road(tree, rep, start_node, end_node)

        print("Cantidad de nodos del camino:", len(dotted_road))

        # Generamos la línea que conecta los puntos extremos en la imagen de fondo
        if plot_interpolate_line or plot_line or plot_dots:
            generate_line(background_img, dotted_road, title, plot_interpolate_line=plot_interpolate_line,
                          plot_line=plot_line, plot_dots=plot_dots, k=k, s=s)

        else:
            return dotted_road
    else:
        raise NotValidExtremePoints(
            'No existen caminos posibles entre los puntos iniciales y finales')


"""# Resultados

## JSD_1D
"""

# JSD 1 dimensión
####### area inicial ######
start_area = {
    'x_start': 0,
    'x_end': 10,
    'y_start': 310,
    'y_end': 325
}
###########################

###### area final #########
end_area = {
    'x_start': 0,
    'x_end': 10,
    'y_start': 1810,
    'y_end': 1820
}
###########################

run_jsd(img_filtered_c=img_filtered_c, img_filtered_f=img_filtered_f, img_filtered_2d=None, jsd_type=JSD.D1, n=8, m=8, title='JSD_1d filtrado cuadrado',
        range=15, start_area=start_area, end_area=end_area, background_img=JSD_original, k=5, s=28_000, plot_interpolate_line=False, plot_line=False, plot_dots=True)

run_jsd(img_filtered_c=img_filtered_c, img_filtered_f=img_filtered_f, img_filtered_2d=None, jsd_type=JSD.D1, n=1, m=30, title='JSD_1d filtro rectangular',
        range=30, start_area=start_area, end_area=end_area, background_img=JSD_original, k=5, s=28_000, plot_interpolate_line=False, plot_line=False, plot_dots=True)

"""##JSD_2d"""

### JSD_2d ###
###### area inicial ######
start_area = {
    'x_start': 0,
    'x_end': 20,
    'y_start': 310,
    'y_end': 320
}
##########################

### JSD_2d ###
###### area final #########

end_area = {
    'x_start': 0,
    'x_end': 20,
    'y_start': 1810,
    'y_end': 1820
}
###########################

run_jsd(img_filtered_c=None, img_filtered_f=None, img_filtered_2d=img_filtered_2d, jsd_type=JSD.D2, n=1, m=30, range=30, start_area=start_area,
        end_area=end_area, background_img=JSD_original, k=5, s=50_000, plot_interpolate_line=False, plot_line=False, plot_dots=True, title='JSD_2d filtrado cuadrado')

run_jsd(img_filtered_c=None, img_filtered_f=None, img_filtered_2d=img_filtered_2d, jsd_type=JSD.D2, n=8, m=8, range=15, start_area=start_area, end_area=end_area,
        background_img=JSD_original, k=5, s=50_000, plot_interpolate_line=False, plot_line=False, plot_dots=True, title='JSD_2d filtrado rectangular')

# Resultado incorrecto
run_jsd(img_filtered_c=None, img_filtered_f=None, img_filtered_2d=img_filtered_2d, jsd_type=JSD.D2, n=20, m=20, range=35, start_area=start_area, end_area=end_area,
        background_img=JSD_original, k=5, s=50_000, plot_interpolate_line=False, plot_line=False, plot_dots=True, title='JSD_2d resultado incorrecto')

"""# Comparaciones utilizadas en la tesis"""


def generate_line_with_zoom(background_img, dotted_road, title, x, y, z, h, spline, k, s):
    """
   Genera el borde interpolado sobre la imagen original como fondo. graficando solo la zona seleccionada ya sea con spline o sin el.

    Args:
        background_img (numpy.ndarray): Imagen de fondo.
        dotted_road (list): Lista de coordenadas de puntos.
        title (str, optional): Título de la figura.
        plot_interpolate_line (bool, optional): Indica si se debe trazar la línea interpolada.
        plot_line (bool, optional): Indica si se debe trazar la línea original de puntos.
        plot_dots (bool, optional): Indica si se deben graficar los puntos.
        k (int, optional): Orden del spline para la interpolación.
        s (int, optional): Valor de suavidad para la interpolación.

    Returns:
        None
    """
    # Obtiene las coordenadas x e y de los puntos
    x_elems = [int(coord.split('-')[1]) for coord in dotted_road]
    y_elems = [int(coord.split('-')[0]) for coord in dotted_road]

    # Interpola la curva con splprep
    tck, u = interpolate.splprep([x_elems, y_elems], k=k, s=s, task=0)
    out = interpolate.splev(u, tck)

    # Crea la figura
    plt.figure(figsize=(10, 10))
    plt.imshow(background_img, cmap='gray')
    plt.title(title)

    # Grafica los puntos, línea original y línea interpolada si se indica
    if spline:
        plt.plot(out[0], out[1], 'b', linewidth='3')
    else:
        plt.plot(x_elems, y_elems, '.', markersize=5, markeredgecolor="red")

    plt.xlim([x, y])
    plt.ylim([z, h])

    plt.show()


"""### Ejecuta todas las corridas utilizadas para poder compararlas"""

# JSD
####### area inicial ######
start_area = {
    'x_start': 0,
    'x_end': 10,
    'y_start': 310,
    'y_end': 325
}
###########################

###### area final #########
end_area = {
    'x_start': 0,
    'x_end': 10,
    'y_start': 1810,
    'y_end': 1820
}
###########################

dotted_road_rect_1d = run_jsd(img_filtered_c=img_filtered_c, img_filtered_f=img_filtered_f, img_filtered_2d=None, jsd_type=JSD.D1,
                              n=1, m=30, title='JSD_1d', range=30, start_area=start_area, end_area=end_area, background_img=JSD_original, k=5, s=28_000)

dotted_road_box_1d = run_jsd(img_filtered_c=img_filtered_c, img_filtered_f=img_filtered_f, img_filtered_2d=None, jsd_type=JSD.D1,
                             title='JSD_1d', n=8, m=8, range=15, start_area=start_area, end_area=end_area, background_img=JSD_original, k=5, s=60_000)

dotted_road_rect_2d = run_jsd(img_filtered_c=None, img_filtered_f=None, img_filtered_2d=img_filtered_2d, jsd_type=JSD.D2,
                              n=1, m=30, range=30, start_area=start_area, end_area=end_area, background_img=JSD_original, k=5, s=50_000, title='JSD_2d')

dotted_road_box_2d = run_jsd(img_filtered_c=None, img_filtered_f=None, img_filtered_2d=img_filtered_2d, jsd_type=JSD.D2,
                             n=8, m=8, range=15, start_area=start_area, end_area=end_area, background_img=JSD_original, k=5, s=60_000, title='JSD_2d')

"""###JSD2D filtrado por bloques cuadrado"""

generate_line_with_zoom(JSD_original, dotted_road_box_2d,
                        'JSD2d filtrado cuadrado borde lineal', 120, 1150, 600, 325, False, 5, 50_000)
generate_line_with_zoom(JSD_original, dotted_road_box_2d,
                        'JSD2d filtrado cuadrado borde lineal con spline', 120, 1150, 600, 325, True, 5, 25_000)

generate_line_with_zoom(JSD_original, dotted_road_box_2d,
                        'JSD2d filtrado cuadrado punta de la superficie', 2600, 3200, 1500, 960, False, 5, 50_000)
generate_line_with_zoom(JSD_original, dotted_road_box_2d,
                        'JSD2d filtrado cuadrado punta de la superficie con spline', 2600, 3200, 1500, 960, True, 5, 25_000)

"""### JSD2D filtrado por bloques rectangulares"""

generate_line_with_zoom(JSD_original, dotted_road_rect_2d,
                        'JSD2d filtrado rectangulo borde lineal', 120, 1150, 600, 325, False, 5, 25_000)
generate_line_with_zoom(JSD_original, dotted_road_rect_2d,
                        'JSD2d filtrado rectangulo borde lineal con spline', 120, 1150, 600, 325, True, 5, 25_000)

generate_line_with_zoom(JSD_original, dotted_road_rect_2d,
                        'JSD2d filtrado rectangular punta de la superficie', 2600, 3200, 1500, 960, False, 5, 25_000)
generate_line_with_zoom(JSD_original, dotted_road_rect_2d,
                        'JSD2d filtrado rectangular punta de la superficie con spline', 2600, 3200, 1500, 960, True, 5, 25_000)

"""###JSD1D filtrado por bloques cuadrado"""

generate_line_with_zoom(JSD_original, dotted_road_box_1d,
                        'JSD1d filtrado cuadrado borde lineal', 120, 1150, 600, 325, False, 5, 50_000)
generate_line_with_zoom(JSD_original, dotted_road_box_1d,
                        'JSD1d filtrado cuadrado borde lineal con spline', 120, 1150, 600, 325, True, 5, 50_000)

generate_line_with_zoom(JSD_original, dotted_road_box_1d,
                        'JSD1d filtrado cuadrado punta de la superficie', 2600, 3200, 1500, 960, False, 5, 50_000)
generate_line_with_zoom(JSD_original, dotted_road_box_1d,
                        'JSD1d filtrado cuadrado punta de la superficie con spline', 2600, 3200, 1500, 960, True, 5, 50_000)

"""###JSD1D filtrado por bloques rectangulares"""

generate_line_with_zoom(JSD_original, dotted_road_rect_1d,
                        'JSD1d filtrado rectangular borde lineal', 120, 1150, 600, 325, False, 5, 50_000)
generate_line_with_zoom(JSD_original, dotted_road_rect_1d,
                        'JSD1d filtrado rectangular borde lineal con spline', 120, 1150, 600, 325, True, 5, 50_000)

generate_line_with_zoom(JSD_original, dotted_road_rect_1d,
                        'JSD1d filtrado rectangular punta de la superficie', 2600, 3200, 1500, 960, False, 5, 50_000)
generate_line_with_zoom(JSD_original, dotted_road_rect_1d,
                        'JSD1d filtrado rectangular punta de la superficie con spline', 2600, 3200, 1500, 960, True, 5, 50_000)

"""# COMPARACIONES

### JSD1 filtrado cuadrado vs JSD1 filtrado rectangular
"""

generate_line_with_zoom(JSD_original, dotted_road_box_1d,
                        'JSD1d filtrado cuadrado borde lineal', 120, 550, 500, 250,  False, 5, 0)

generate_line_with_zoom(JSD_original, dotted_road_rect_1d,
                        'JSD1d filtrado rectangular borde lineal', 120, 550, 500, 250,  False, 5, 0)

generate_line_with_zoom(JSD_original, dotted_road_box_1d,
                        'JSD1d filtrado cuadrado punta de la superficie', 2600, 3200, 1600, 900, False, 5, 0)

generate_line_with_zoom(JSD_original, dotted_road_rect_1d,
                        'JSD1d filtrado rectangular punta de la superficie', 2600, 3200, 1600, 900,  False, 5, 0)

"""### JSD2 filtrado cuadrado vs JSD2 filtrado rectangular"""

generate_line_with_zoom(JSD_original, dotted_road_box_2d,
                        'JSD2d filtrado cuadrado borde lineal', 120, 550, 500, 250,  False, 5, 0)

generate_line_with_zoom(JSD_original, dotted_road_rect_2d,
                        'JSD2d filtrado rectangular borde lineal', 120, 550, 500, 250,  False, 5, 0)

generate_line_with_zoom(JSD_original, dotted_road_box_2d,
                        'JSD2d filtrado cuadrado punta de la superficie', 2600, 3200, 1600, 900, False, 5, 0)

generate_line_with_zoom(JSD_original, dotted_road_rect_2d,
                        'JSD2d filtrado rectangular punta de la superficie', 2600, 3200, 1600, 900,  False, 5, 0)

"""## Coparacion JSD1 vs JSD2 rectangular"""

generate_line_with_zoom(JSD_original, dotted_road_rect_1d,
                        'JSD1d filtrado rectangular borde lineal', 120, 550, 500, 250,  False, 5, 0)

generate_line_with_zoom(JSD_original, dotted_road_rect_2d,
                        'JSD2d filtrado rectangular borde lineal', 120, 550, 500, 250,  False, 5, 0)

generate_line_with_zoom(JSD_original, dotted_road_rect_1d,
                        'JSD1d filtrado rectangular punta de la superficie', 2600, 3200, 1600, 900,  False, 5, 0)

generate_line_with_zoom(JSD_original, dotted_road_rect_2d,
                        'JSD2d filtrado rectangular punta de la superficie', 2600, 3200, 1600, 900,  False, 5, 0)
